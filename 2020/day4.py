import os
import sys
#Add the dir above day run as path for easy import
root_folder = os.path.abspath(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(root_folder)
from itertools import groupby
from utils import support
from utils.loc import linecount
from utils.support import logger, console, log_time

#Set day/year global variables
DAY:int = 4 #datetime.now().day
YEAR:int = 2020 #datetime.now().year

PASS_DICT = {
    "byr" : ("(Birth Year)"),
    "iyr" : "(Issue Year)",
    "eyr" : "(Expiration Year)",
    "hgt" : "(Height)",
    "hcl" : "(Hair Color)",
    "ecl" : "(Eye Color)",
    "pid" : "(Passport ID)",
    "cid" : "(Country ID)",
}
def validate_entries(entries:list)->bool:
    """Basic idea is to cause any entry to fail if it doesn't pass the validation checks

    Args:
        entries (list): List of strings grouped by the groupby function

    Returns:
        bool: Whether or not the passport is valid
    """    
    for entry in entries:
        key, val = entry.split(":")
        match key:
            case "byr":
                if len(val) != 4 and not val.isdigit():
                    return False
                if int(val) not in range(1920, 2003):
                    return False
            case "iyr":
                if len(val) != 4 and not val.isnumeric():
                    return False
                if int(val) not in range(2010, 2021):
                    return False
            case "eyr":
                if len(val) != 4 and not val.isnumeric():
                    return False
                if int(val) not in range(2020, 2031):
                    return False
            case "hgt":
                if val.endswith("cm"):
                    if int(val[:-2]) not in range(150, 194):
                        return False
                elif val.endswith("in"):
                    if int(val[:-2]) not in range(59, 77):
                        return False
                else:
                    return False
            case "hcl":
                if (val.startswith("#")) & (len(val[1:])==6):
                    for v in val[1:]:
                        if v.isdigit(): 
                            if int(v) not in range(0, 10):
                                return False
                        elif v.isalpha():
                            if v not in ["a","b","c","d","e","f"]:
                                return False
                else:   
                    return False
            case "ecl":
                if val not in ["amb", "blu", "brn", "gry", "grn", "hzl", "oth"]:
                    return False
            case "pid":
                if not val.isnumeric() & (len(val) == 9):
                    return False
            # case "cid": No case for cid because we ignore it. 
            #     pass

    return True

def problemsolver(dataset:list, part:int)->int:
    valid, cid = 0, set(["cid"])
    datal = groupby(dataset, key=lambda x:x == "")
    # the key generated by a groupby/lambda can be used to test if its an empty group
    data = [" ".join(group) for is_empty, group in datal if not is_empty]
    for passport in data:
        entries = passport.split(" ")
        if part == 2:
            trust = validate_entries(entries)
            if not trust:
                continue
        keys = [entry.split(":")[0] for entry in entries]
        diff = set(PASS_DICT.keys()) - set(keys)
        if (not diff) | (diff == cid):
            valid += 1
        
    return valid
@log_time
def part_A():
    logger.info("Solving part A")
    #to check your cache status when you need cache nooooow call J.... G.... WENTWORTH. 
    support._877_cache_now() 
    #Pull puzzle description and testdata
    tellstory, testdata = support.pull_puzzle(DAY, YEAR, 1, False, -4)
    console.log(f"{tellstory}")
    logger.info("testdata table")
    [logger.info(row) for row in testdata]
    #Solve puzzle w/testcase
    testcase = problemsolver(testdata, 1)
    #Assert testcase
    assert testcase == 2, f"Test case A failed returned:{testcase}"
    logger.info(f"Test case passed for part A")
    #Solve puzzle with full dataset
    answerA = problemsolver(data, 1)
    return answerA

@log_time
def part_B():
    logger.info("Solving part B")
    #Check cache status
    support._877_cache_now()
    #Pull puzzle description and testdata
    tellstory, testdata = support.pull_puzzle(DAY, YEAR, 2, False, -1)
    console.log(f"{tellstory}")
    [logger.info(row) for row in testdata]
    #Solve puzzle w/testcase
    testcase = problemsolver(testdata, 2)
    #Assert testcase
    assert testcase == 4, f"Test case B failed returned:{testcase}"
    logger.info(f"Test case: {testcase} passed for part B")
    #Solve puzzle with full dataset
    answerB = problemsolver(data, 2)
    return answerB

def main():
    global data
    data = support.pull_inputdata(DAY, YEAR)
    #Stack the data horizontally 100 times.
    # Solve part A
    resultA = part_A()
    fails = [8400518384267]
    if resultA in fails:
        logger.warning(f"Answer already submitted\nAnswer: {resultA}")
        exit()
    else:
        logger.info(f"part A possible solution: \n{resultA}\n")
    # # support.submit_answer(DAY, YEAR, 1, resultA)

    # #Solve part B
    resultB = part_B()
    fails = [252]
    if resultB in fails:
        logger.warning(f"Answer already submitted\nAnswer: {resultB}")
        exit()
    else:
        logger.info(f"part B possible solution: \n{resultB}\n")
    # support.submit_answer(DAY, YEAR, 2, resultB)

    #Recurse lines of code
    LOC = linecount(f'./{YEAR}/day{DAY}.py')
    logger.info(f"Lines of code: {LOC}")

    #Delete the cache after submission
    support._877_cache_now(".cache", True)
    
if __name__ == "__main__":
    main()

########################################################
#Notes
#Part A Notes
